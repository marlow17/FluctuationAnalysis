%
% Author: Stilian Stoev (C), sstoev@math.bu.edu
%
% Generates paths of fractional Gaussian noise.  The algorithm exploits
% the efficiency of the FFT algorithm.
%
% * Written by: Stilian Stoev <sstoev@math.bu.edu>.
% * Latest revision: October 5, 2003.
%
% * When 0<H<1/2
%    The generated paths have "exact distributions", discarding
%  the effect of the random number generator.  The code uses
%  the "corrected" algorithm of Steven B. Lowen, 1999
%  "Efficient Generation of Fractional Brownian Motion for
%   Simulation of Infrared Focal-plane Array Calibration Drift"
%
% * When 1/2<H<1
%   The paths are generated by using a truncated symmetric moving average
% filter.  The filter coefficients are computed via IFFT of the square
% root of the FFT of the covariances of the FGN.
%   The moving average is also computed by using the FFT algorithm.
%
%  *Remark* This method is simple, and probably similar to "circulant
% embedding techniques", numerically.  It is, however, more general and
% easier to extend for arbitrary covariance strucures.  It is originally
% due to Stilian Stoev <sstoev@math.bu.edu>. Please email if you know
% of other similar algorithms.
%
% Input:
%   sigma <- the variance
%       H <- Hurst
%       n <- number of independent samples to be generated.
%       N <- the size of the sample
%       M <- 1/2 of the length of the filter to be used
%            (used only for 1/2<H<1)
%   force <- if force==1, then the FFT's in the case 1/2 <H< 1
%            are forced to be of dyadic complexity.
%
% *Note: The generation is most efficient if:
%         * N       is an integer power of 2 (when 0<H<1/2)
%         * (N+2*M) is an integer power of 2 (when 1/2<H<1)
%
% Output:
%       f <- (nxN) matrix. Each row gives a sample path of FGN.
%
% Usage:
%  f=fftfgn(sigma,H,n,N,M,force);
%
function f=fftfgn(sigma,H,n,N,M,force,varargin)

if H==1/2
    f=sigma*randn(n,N);
elseif (H>1/2)&& (H<=1)
    t=-M:M;
    co=.5*sigma^2*(abs(t+1).^(2*H) + abs(t-1).^(2*H) - 2*abs(t).^(2*H));
    if force
        nM=2^(fix(log2(2*M+1))+1);
    else
        nM=2*M+1;
    end;
    co_hat=fft(co,nM);
    ft=real(ifft(abs(co_hat).^.5,nM));
    ft=[ft(fix(nM/2)+1:nM), ft(1:fix(nM/2))];
    R=randn(n,2*M+N);
    if ~isempty(varargin)
        fprintf(' Generating n=%d paths ',n);
    end;
    f=zeros(n,N);
    for i=1:n
        fi=fftconv(R(i,:),ft,force);
        f(i,:)=fi(2*M:2*M+N-1);
        if ~isempty(varargin)
            fprintf('.');
        end;
    end;
    if ~isempty(varargin)
        fprintf(' done.\n');
    end;
elseif (H<1/2) && (H>0)
    G1=randn(n,N-1);
    G2=randn(n,N-1);
    G=(G1+sqrt(-1)*G2)/sqrt(2);
    GN=randn(n,1);
    H2=2*H;
    R=(1-((1:N-1)/N).^H2);
    R=[1 R 0 R(N-1:-1:1)];
    S=ones(n,1)*(abs(fft(R,2*N)).^.5);
    X=[zeros(n,1) G, GN, conj(G(:,N-1:-1:1)) ].*S;
    x=ifft(X',2*N)';
    y=sqrt(N)*real((x(:,1:N)-x(:,1)*ones(1,N)));
    f=sigma*N^H*[y(:,1), diff(y,1,2)];
else
    error('The value of the Hurst parameter H is out of the range (0,1]');
end
%%

%
% Author:  Stilian Stoev (C), sstoev@math.bu.edu
%
% This function computes the discrete convolution of the vectors
% a and b, efficiently, by using the FFT algorithm.
%
% input:
%  a <- a vector
%  b <- a vector with the same dimensions as a
%  force <- if force == 1, then the FFT's are "forced" to be
%           of dyadic complexity.
%
% output:
%  c <- the discrete convolution of a and b, that is,
%       (a(1)*b(1), a(1)*b(2)+a(2)*b(1), ...)
%
% usage:
%   c = fftconv(a,b,force);
%
% Written by sstoev@math.bu.edu
%
function c = fftconv(a,b,force)

na = length(a);
nb = length(b);

if force
    n = 2^(fix(log2(na+nb))+1);
else
    n=na+nb;
end;
A = fft(a,n);
B = fft(b,n);

c = ifft(A.*B,n);
c = real(c(1:na+nb-1));


